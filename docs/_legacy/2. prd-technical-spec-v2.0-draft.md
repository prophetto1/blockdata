# PRD Technical Specification v2.0 (Draft) - Canonical Output Contract + User-Defined Schemas

Status: Draft (reconstructed and consolidated after migration drift)
Last updated: 2026-02-07

This is Document 2 (future-oriented): how the PRD maps to architecture, with the **canonical output contract** that development must implement.

Primary source material:
- `docs/_drifted/prd-v4.md` (canonical record format + schema/run model)
- `docs/core/core-docs/doc-3/supabase-core-pipeline-tech-spec.md` (export rules)
- `docs/_complete/ddl-plan.md` (DDL intent)
- `docs/tests/user-defined/prose-optimizer-v1.schema.json` (example user-defined schema artifact)

---

## 1) Core Invariants

1. **Immutable is never mutated after ingest**
   - After ingest completes, the extracted immutable substrate is fixed.

2. **User-defined schemas are overlays, not edits to immutable**
   - All schema outputs (tags, extracted fields, rewrites, comments, signals) live in a mutable overlay layer.

3. **Multi-schema is a first-class requirement**
   - A single document's immutable block inventory must support attaching many schemas.
   - A single schema must be reusable across many documents.

4. **The export format is the contract**
   - Canonical output is JSON (per block) and JSONL (one JSON per line).
   - The database is storage; export is assembled on demand.

---

## 2) Entities (How Multi-Schema Works)

These names match the Phase 2 model used throughout the repo:

- **Document (immutable substrate):**
  - Identified by `doc_uid`.
  - Backed by immutable tables: `documents` + `blocks`.

- **Schema (user-defined schema artifact):**
  - A reusable schema definition owned by a user.
  - Backed by the `schemas` table.
  - Has stable identifiers:
    - `schema_ref` (user-facing slug)
    - `schema_uid` (content hash of canonicalized schema JSON)

- **Run (schema attached to a document):**
  - A binding of one `doc_uid` to one schema for a specific execution instance.
  - Backed by `annotation_runs`.
  - Identified by `run_id`.

- **Overlay (per-block user-defined output for a run):**
  - One row per `(run_id, block_uid)`.
  - Backed by `block_annotations.annotation_jsonb`.

This creates the many-to-many relationship you want:
- A **document** has many schema attachments (many runs).
- A **schema** appears on many documents (many runs).

UI implication (product requirement):
- Document detail view shows all attached schemas (runs) for that document.
- Schema detail view shows all documents that have runs using that schema.

---

## 3) Schema Artifact Format (What Users Upload)

The docs already contain an example of a user-defined schema artifact:
- `docs/tests/user-defined/prose-optimizer-v1.schema.json`

This artifact describes the expected shape of **per-block** output.

Important: this schema defines the shape of the overlay payload (what ends up under `user_defined.data` at export time), not the immutable substrate.

Validation approach (v0):
- Validate: "is valid JSON" + "has required top-level keys/types".
- No generalized meta-schema is required for v0 (hard-coded validator is acceptable).

---

## 4) Canonical Output: One Block Record (JSON)

Each exported block is one JSON object with exactly two top-level keys:

- `immutable`: deterministic substrate derived at ingest time.
- `user_defined`: user-defined schema overlay for a specific schema attachment (run).

### 4.1 Canonical Shape

```json
{
  "immutable": {
    "immutable_schema_ref": "md_prose_v1",
    "envelope": {
      "doc_uid": "...",
      "source_uid": "...",
      "md_uid": "...",
      "source_type": "md",
      "source_locator": "...",
      "md_locator": "...",
      "doc_title": "...",
      "uploaded_at": "...",

      "block_uid": "...",
      "block_type": "paragraph",
      "block_index": 37,
      "section_path": ["..."],
      "char_span": [0, 0]
    },
    "content": { "original": "..." }
  },
  "user_defined": {
    "schema_ref": null,
    "schema_uid": null,
    "data": {}
  }
}
```

Notes:
- Phase 1 keeps `user_defined` inert (null schema identifiers + empty `data`).
- Phase 2 populates `user_defined` from the run + overlays (see below).
- Some older docs use the key name `annotation` for what is conceptually the same `user_defined` overlay. This document standardizes on `user_defined`.

### 4.2 Where Fields Come From (Source of Truth)

- `immutable.*` is assembled from `documents` + `blocks`.
- `user_defined.schema_ref` and `user_defined.schema_uid` come from the run's schema.
- `user_defined.data` comes from the run's per-block overlay row.

---

## 5) Canonical Output: JSONL (One Block Record Per Line)

JSONL is newline-delimited JSON:
- Each line is exactly one block record (the JSON shape above).
- A JSONL file is the ordered concatenation of those lines.

Ordering rule:
- Export MUST order by `block_index` ascending (stable reading order).

Export variants:
- **Phase 1 export** (immutable only): parameterized by `doc_uid`.
  - `user_defined` is always inert: `{ schema_ref: null, schema_uid: null, data: {} }`
- **Phase 2 export** (immutable + a specific schema overlay): parameterized by `run_id`.
  - `user_defined.schema_ref` and `user_defined.schema_uid` are sourced from the run's schema.
  - `user_defined.data` is sourced from `block_annotations.annotation_jsonb` for `(run_id, block_uid)`.

Multi-schema note:
- A document with many attached schemas produces many Phase 2 JSONL exports (one per `run_id`), each representing one schema overlay over the same immutable block inventory.

---

## 6) Why This Design Exists (Intent)

This split is intentional:

- **Reuse without re-ingest:** run many distinct schemas (citation extraction, prose editing, KG metadata) over the same immutable blocks.
- **Provenance and auditability:** every derived field traces back to an immutable block with stable identity.
- **Parallelization:** the block inventory creates stable, independent units of work; workers can operate concurrently without colliding.
- **Comparability:** you can compare outputs across schemas, and across runs of the same schema, because the join key (`block_uid`) is stable.
- **No drift in the substrate:** you can evolve schemas and runs without mutating the original content/provenance.

