# PRD Technical Specification Template — Document 2

**Purpose:** How the PRD maps to architecture — tables, APIs, constraints
**Time Orientation:** Future (how to build it)
**Status:** Once finalized, this document is LOCKED and never modified.
**Dependency:** This document is DERIVED from Document 1 (PRD). Write the PRD first.

---

## Section 1: Architectural Principles

State the non-negotiable rules that govern all technical decisions.

### 1.1 Core Invariants

| Principle | Statement | Rationale |
|-----------|-----------|-----------|
| [Principle 1] | [What must always be true] | [Why this matters] |
| [Principle 2] | [What must always be true] | [Why this matters] |
| [Principle 3] | [What must always be true] | [Why this matters] |

*Example:*
| Principle | Statement | Rationale |
|-----------|-----------|-----------|
| Immutability | Block content is never modified after creation | Enables stable provenance and reproducible exports |
| Determinism | Same input always produces same block_uid | Content-addressed identity for deduplication |
| Separation | Annotation is overlay, not mutation | Same blocks serve multiple schemas without re-ingest |

### 1.2 Service Boundaries

Define what each service owns and what it cannot touch.

| Service | Owns | Does Not Touch |
|---------|------|----------------|
| [Service 1] | [Resources] | [Off-limits resources] |
| [Service 2] | [Resources] | [Off-limits resources] |

---

## Section 2: Data Model

### 2.1 Entity Relationship Overview

```
[ASCII diagram or description of entity relationships]

Example:
documents (1) ──────< blocks (N)
     │
     └──────< annotation_runs (N) ──────< block_annotations (N)
                    │
                    └── schemas (1)
```

### 2.2 Table Specifications

For each table, define columns, types, constraints, and purpose.

---

#### Table: `[table_name]`

**Purpose:** [What this table represents]

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| [column_1] | [TYPE] | [PK/FK/UNIQUE/NOT NULL/etc.] | [What it stores] |
| [column_2] | [TYPE] | [Constraints] | [What it stores] |
| [column_3] | [TYPE] | [Constraints] | [What it stores] |

**Business Rules:**
- [Rule 1]
- [Rule 2]

**Indexes:**
- `idx_[name]` on `([columns])` — [Purpose]

---

#### Table: `[table_name_2]`

**Purpose:** [What this table represents]

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| [column_1] | [TYPE] | [Constraints] | [What it stores] |
| [column_2] | [TYPE] | [Constraints] | [What it stores] |

**Business Rules:**
- [Rule 1]

**Indexes:**
- `idx_[name]` on `([columns])` — [Purpose]

---

## Section 3: Identity Model

Define how entities are identified and how identity is computed.

### 3.1 Identity Scheme

| Entity | Identifier | Computation | Uniqueness Scope |
|--------|------------|-------------|------------------|
| [Entity 1] | [id_name] | [How it's generated] | [Global/Per-user/Per-parent] |
| [Entity 2] | [id_name] | [How it's generated] | [Uniqueness scope] |

*Example:*
| Entity | Identifier | Computation | Uniqueness Scope |
|--------|------------|-------------|------------------|
| Document source | source_uid | SHA256(original_bytes) | Global |
| Markdown content | md_uid | SHA256(markdown_bytes) | Global |
| Document instance | doc_uid | SHA256(md_uid + immutable_schema_ref) | Global |
| Block | block_uid | SHA256(doc_uid + ":" + block_index) | Global |

### 3.2 Identity Relationships

```
[Diagram or description showing how identities relate]

Example:
source_uid (upload)
    → md_uid (conversion)
        → doc_uid (schema binding)
            → block_uid (parsing)
```

---

## Section 4: API Contract

### 4.1 Endpoints Overview

| Endpoint | Method | Purpose | Auth Required |
|----------|--------|---------|---------------|
| [/path/1] | [POST/GET/etc.] | [What it does] | [Yes/No] |
| [/path/2] | [Method] | [What it does] | [Yes/No] |

### 4.2 Endpoint Specifications

---

#### `[METHOD] /path/endpoint`

**Purpose:** [What this endpoint does]

**Request:**
```json
{
  "field_1": "[type] — [description]",
  "field_2": "[type] — [description]"
}
```

**Response (Success):**
```json
{
  "field_1": "[type] — [description]",
  "field_2": "[type] — [description]"
}
```

**Response (Error):**
```json
{
  "error": "[error code]",
  "message": "[human-readable message]"
}
```

**Status Codes:**
- `200` — [When returned]
- `400` — [When returned]
- `401` — [When returned]
- `404` — [When returned]

---

## Section 5: Canonical Output Format

Define the exact structure of exported data.

### 5.1 Export Format: [Format Name, e.g., JSONL]

**File structure:**
```
[Description of file format]
```

**Record schema:**
```json
{
  "field_1": "[type] — [description]",
  "field_2": "[type] — [description]",
  "nested_object": {
    "subfield_1": "[type] — [description]"
  }
}
```

**Example record:**
```json
{
  // Concrete example with realistic data
}
```

### 5.2 Export Branches

| Branch | Purpose | Trigger | Output |
|--------|---------|---------|--------|
| [Branch 1] | [What it's for] | [When it runs] | [What it produces] |
| [Branch 2] | [What it's for] | [When it runs] | [What it produces] |

---

## Section 6: Security Model

### 6.1 Authentication

| Method | Scope | Implementation |
|--------|-------|----------------|
| [Method 1] | [What it protects] | [How it works] |
| [Method 2] | [What it protects] | [How it works] |

### 6.2 Authorization (Row-Level Security)

| Table | Policy | Rule |
|-------|--------|------|
| [table_1] | [SELECT/INSERT/UPDATE/DELETE] | [RLS condition] |
| [table_2] | [Policy type] | [RLS condition] |

*Example:*
| Table | Policy | Rule |
|-------|--------|------|
| documents | SELECT | `owner_id = auth.uid()` |
| documents | INSERT | `owner_id = auth.uid()` |
| blocks | SELECT | via FK join to documents where `owner_id = auth.uid()` |

### 6.3 Data Protection

| Concern | Mitigation |
|---------|------------|
| [Concern 1] | [How it's addressed] |
| [Concern 2] | [How it's addressed] |

---

## Section 7: Integration Points

### 7.1 External Services

| Service | Purpose | Interface | Data Flow |
|---------|---------|-----------|-----------|
| [Service 1] | [What it does] | [API/Queue/etc.] | [Direction and what's exchanged] |
| [Service 2] | [What it does] | [Interface type] | [Data flow] |

### 7.2 Event System

| Event | Trigger | Payload | Consumers |
|-------|---------|---------|-----------|
| [Event 1] | [What causes it] | [What it contains] | [Who listens] |
| [Event 2] | [Trigger] | [Payload] | [Consumers] |

### 7.3 Extension Points

Describe where the system is designed to be extended without architectural changes.

| Extension Point | What Can Be Added | Constraints |
|-----------------|-------------------|-------------|
| [Point 1] | [What's pluggable] | [Limits/rules] |
| [Point 2] | [What's pluggable] | [Limits/rules] |

---

## Appendix A: Constraint Definitions

List all database constraints with their exact definitions.

### Table: `[table_name]`

| Constraint Name | Definition | Purpose |
|-----------------|------------|---------|
| [constraint_1] | `[SQL expression]` | [What it enforces] |
| [constraint_2] | `[SQL expression]` | [What it enforces] |

---

## Appendix B: Index Definitions

List all indexes with their exact definitions and purpose.

| Index Name | Table | Columns | Type | Purpose |
|------------|-------|---------|------|---------|
| [idx_1] | [table] | [columns] | [btree/partial/etc.] | [What queries it serves] |
| [idx_2] | [table] | [columns] | [Type] | [Purpose] |

---

## Writing Guidelines

1. **Trace to PRD** — Every table/endpoint should map to a PRD capability
2. **Be precise** — Use exact types, exact constraint syntax
3. **No ambiguity** — If a developer reads this, they should be able to implement without guessing
4. **Future state** — Describe the complete system, not what's built today
5. **Stable contracts** — Once locked, these definitions don't change
